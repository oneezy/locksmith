function $Resolve(e,r){var n=1,i=2,t={},s=[],o=t,u=extend(e.when(t),{$$promises:t,$$values:t});this.study=function(t){function $(e,o){if(c[o]!==i){if(f.push(o),c[o]===n)throw f.splice(0,f.indexOf(o)),new Error("Cyclic dependency: "+f.join(" -> "));if(c[o]=n,isString(e))a.push(o,[function(){return r.get(e)}],s);else{var u=r.annotate(e);forEach(u,function(e){e!==o&&t.hasOwnProperty(e)&&$(t[e],e)}),a.push(o,e,u)}f.pop(),c[o]=i}}function l(e){return isObject(e)&&e.then&&e.$$promises}if(!isObject(t))throw new Error("'invocables' must be an object");var a=[],f=[],c={};return forEach(t,$),t=f=c=null,function(n,i,t){function s(){--p||(m||merge(d,i.$$values),h.$$values=d,h.$$promises=!0,delete h.$$inheritedValues,c.resolve(d))}function $(e){h.$$failure=e,c.reject(e)}function f(i,o,u){function l(e){f.reject(e),$(e)}function a(){if(!isDefined(h.$$failure))try{f.resolve(r.invoke(o,t,d)),f.promise.then(function(e){d[i]=e,s()},l)}catch(e){l(e)}}var f=e.defer(),c=0;forEach(u,function(e){v.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(c++,v[e].then(function(r){d[e]=r,--c||a()},l))}),c||a(),v[i]=f.promise}if(l(n)&&void 0===t&&(t=i,i=n,n=null),n){if(!isObject(n))throw new Error("'locals' must be an object")}else n=o;if(i){if(!l(i))throw new Error("'parent' must be a promise returned by $resolve.resolve()")}else i=u;var c=e.defer(),h=c.promise,v=h.$$promises={},d=extend({},n),p=1+a.length/3,m=!1;if(isDefined(i.$$failure))return $(i.$$failure),h;i.$$inheritedValues&&merge(d,i.$$inheritedValues),i.$$values?(m=merge(d,i.$$values),h.$$inheritedValues=i.$$values,s()):(i.$$inheritedValues&&(h.$$inheritedValues=i.$$inheritedValues),extend(v,i.$$promises),i.then(s,$));for(var w=0,b=a.length;b>w;w+=3)n.hasOwnProperty(a[w])?s():f(a[w],a[w+1],a[w+2]);return h}},this.resolve=function(e,r,n,i){return this.study(e)(r,n,i)}}$Resolve.$inject=["$q","$injector"],angular.module("ui.router.util").service("$resolve",$Resolve);